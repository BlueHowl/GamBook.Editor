package org.helmo.gbeditor.infrastructures.jdbc;

import org.helmo.gbeditor.infrastructures.dto.BookDTO;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Statement;

/**
 * Crée et détruit le schéma de la Bd
 * Sauvegarde des projets
 */
public class SqlStorage implements AutoCloseable {
    private final Connection connection;
    public static final String CREATE_BOOK_TABLE_STMT = "CREATE TABLE BOOK(" +
            "id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, " +
            "title VARCHAR(150) NOT NULL, " +
            "summary VARCHAR (500) NOT NULL," +
            "author VARCHAR(100) NOT NULL," +
            "isbn VARCHAR(13))";

    public static final String CREATE_PAGE_TABLE_STMT = "CREATE TABLE PAGE(" +
            "pageNumber INT PRIMARY KEY, " +
            "text VARCHAR(150) NOT NULL)";

    public static final String CREATE_CHOICE_TABLE_STMT = "CREATE TABLE CHOICE(" +
            "id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, " +
            "text VARCHAR(150) NOT NULL," +
            "page_id INT," +
            "FOREIGN KEY(page_id) REFERENCES PAGE(pageNumber))";

    public static final String INSERT_TABLE_STMT = "INSERT INTO BOOK" +
            "(title, summary, author, isbn)" +
            " VALUES (?, ?, ?, ?)";

    public SqlStorage(Connection con) {
        this.connection = con;
    }

    public void setup() {
        try (Statement createStatement = connection.createStatement()) {
            createStatement.executeUpdate(CREATE_BOOK_TABLE_STMT);
            createStatement.executeUpdate(CREATE_PAGE_TABLE_STMT);
            createStatement.executeUpdate(CREATE_CHOICE_TABLE_STMT);
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    public void tearDown() {
        try (Statement createStatement = connection.createStatement()) {
            createStatement.executeUpdate("DROP TABLE BOOK");
            createStatement.executeUpdate("DROP TABLE PAGE");
            createStatement.executeUpdate("DROP TABLE CHOICE");
        } catch (SQLException e) {
            throw new UnableToTearDownException(e);
        }
    }
/*
    public void save(BookDTO p) {
        try (PreparedStatement insertStmt = connection.prepareStatement(INSERT_TABLE_STMT, Statement.RETURN_GENERATED_KEYS)) {
            insertStmt.setString(1,p.getName());
            insertStmt.setString(2, p.getDescription());
            insertStmt.setString(3, "Project");
            insertStmt.executeUpdate();
            addToInsert(insertStmt, p);

            p.getTasks().forEachRemaining(t -> addToInsert(insertStmt, t));
            p.getPhases().forEach(t -> addToInsert(insertStmt, t));

            insertStmt.executeBatch();
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    private void addToInsert(PreparedStatement insertStmt, ProjectElement e) {
        try {
            insertStmt.setString(1,e.getName());
            insertStmt.setString(2, e.getDescription());
            insertStmt.setString(3, e.getClass().getName());
            insertStmt.setInt(4, (int) e.getParentId());
            insertStmt.addBatch();
        } catch (SQLException ex) {
            throw new RuntimeException(ex);
        }
    }
*/
    private void saveOrUpdate(BookDTO p) throws SQLException {
      
    }


    private void insert(BookDTO pe) throws SQLException {
      
    }

    @Override
    public void close() throws Exception {
        try {
            connection.close();
        } catch (SQLException ex) {
            throw new DeconnectionFailedException(ex);
        }
    }

    public BookDTO load(long id) {
		return null;
    }

}
